# Implementation Plan: Radius.Compute/containers Kubernetes Recipe (Alpha Stage)

**Document Version:** 1.0  
**Date:** October 8, 2025  
**Target Maturity Level:** Alpha  
**Platform:** Kubernetes  
**IaC Language:** Bicep  

---

## Executive Summary

This document provides a detailed implementation plan for developing the initial Kubernetes Bicep recipe for the `Radius.Compute/containers` resource type. The recipe will replace the existing Go renderer chain with a declarative Bicep template using the Bicep Kubernetes extension (preview).

**Primary Goal:** Enable the October 17, 2025 demo by deploying a simple container application to Kubernetes with Redis connectivity.

---

## 1. File Inventory

### 1.1 Required Files

| File Path | Purpose | Dependencies |
|-----------|---------|--------------|
| `Compute/containers/recipes/kubernetes/bicep/kubernetes-containers.bicep` | Main recipe implementation | None (references context parameter) |
| `Compute/containers/recipes/kubernetes/bicep/README.md` | Platform engineer documentation | Recipe implementation |
| `Compute/containers/test/app.bicep` | Test application for recipe validation | Resource type definition in containers.yaml |
| `Compute/containers/test/README.md` | Test documentation (optional but recommended) | Test app.bicep |

### 1.2 Modified Files

| File Path | Modification Type | Purpose |
|-----------|------------------|---------|
| `bicepconfig.json` | Auto-updated by build | Adds containers extension reference |
| `Compute/containers/containers.yaml` | Documentation enhancement | Add usage examples in descriptions |

### 1.3 Generated Artifacts

| Artifact | Generated By | Purpose |
|----------|--------------|---------|
| `containers-extension.tgz` | `make build-resource-type` | Bicep extension package |
| OCI registry reference | `make build-bicep-recipe` | Published recipe in local registry |

---

## 2. Implementation Details per File

### 2.1 Main Recipe: `kubernetes-containers.bicep`

#### A. Purpose and Scope

This is the core recipe implementation that:
- Receives container specifications from Radius resource properties
- Creates Kubernetes Deployment, Service, Secret, and RBAC resources
- Implements multi-container support, environment variable injection, and volume mounting
- Supports Dapr sidecar, manual scaling, and custom metadata extensions
- Returns connection information (host, port) for dependent resources

**Integration Point:** Called by Radius deployment engine when a `Radius.Compute/containers` resource is deployed.

#### B. Key Implementation Challenges

1. **Multi-Container Iteration**: Must iterate over `containers` object map (not array) to create container specs
2. **Environment Variable Complexity**: 
   - Direct values from `container.env`
   - Connection-injected values from `connections` object
   - Secret references via `valueFrom.secretKeyRef`
3. **Conditional Resource Creation**:
   - Service only when ports are defined
   - Secrets only when connections exist or env vars have secret refs
   - RBAC resources always created for pod access
4. **Extension Logic**:
   - Dapr annotations added conditionally
   - Metadata merged from platformOptions
   - Replica count from `replicas` property
5. **Volume Types**: Must handle emptyDir volumes in Alpha stage (persistent volumes in future phases)

#### C. Content Structure

```bicep
// ===== SECTION 1: PARAMETER DEFINITIONS =====
@description('Radius context with resource metadata and runtime info')
param context object

// ===== SECTION 2: KUBERNETES EXTENSION CONFIGURATION =====
extension kubernetes with {
  kubeConfig: ''
  namespace: context.runtime.kubernetes.namespace
} as kubernetes

// ===== SECTION 3: VARIABLE DECLARATIONS =====
// - Extract resource properties
// - Build labels and annotations
// - Prepare environment variables
// - Configure volumes

// ===== SECTION 4: KUBERNETES RESOURCES =====
// 4.1 ServiceAccount
// 4.2 Role (RBAC)
// 4.3 RoleBinding (RBAC)
// 4.4 Secret (conditional)
// 4.5 Deployment
// 4.6 Service (conditional)

// ===== SECTION 5: OUTPUTS =====
// - Connection information for dependent resources
```

#### D. Recipe Parameters

**Input from Context Object:**

```bicep
// From context.resource.properties (Radius.Compute/containers schema)
var containers = context.resource.properties.containers          // Required: map of container specs
var connections = context.resource.properties.?connections ?? {} // Optional: resource connections
var volumes = context.resource.properties.?volumes ?? {}         // Optional: volume definitions
var replicas = context.resource.properties.?replicas ?? 1        // Optional: replica count
var extensions = context.resource.properties.?extensions ?? {}   // Optional: extensions object
var platformOptions = context.resource.properties.?platformOptions ?? {} // Optional: platform config

// From context metadata
var resourceName = context.resource.name
var applicationName = context.application.name
var namespace = context.runtime.kubernetes.namespace
```

**Example Values for Demo Scenario:**

```bicep
// Demo container calling this recipe would have:
containers = {
  demo: {
    image: 'ghcr.io/radius-project/samples/demo:latest'
    ports: {
      web: {
        containerPort: 3000
      }
    }
  }
}
connections = {
  redis: {
    source: '<redis-resource-id>'
    // Radius injects: CONNECTION_REDIS_HOST, CONNECTION_REDIS_PORT, etc.
  }
}
```

#### E. Resource Generation Logic

**ServiceAccount Resource:**
```bicep
resource serviceAccount 'core/ServiceAccount@v1' = {
  metadata: {
    name: resourceName
    namespace: namespace
    labels: commonLabels
  }
}
```

**Role Resource (RBAC):**
```bicep
resource role 'rbac.authorization.k8s.io/Role@v1' = {
  metadata: {
    name: resourceName
    namespace: namespace
    labels: commonLabels
  }
  rules: [
    {
      apiGroups: ['']
      resources: ['pods', 'services', 'secrets']
      verbs: ['get', 'list', 'watch']
    }
  ]
}
```

**RoleBinding Resource:**
```bicep
resource roleBinding 'rbac.authorization.k8s.io/RoleBinding@v1' = {
  metadata: {
    name: resourceName
    namespace: namespace
    labels: commonLabels
  }
  subjects: [
    {
      kind: 'ServiceAccount'
      name: serviceAccount.metadata.name
      namespace: namespace
    }
  ]
  roleRef: {
    kind: 'Role'
    name: role.metadata.name
    apiGroup: 'rbac.authorization.k8s.io'
  }
}
```

**Secret Resource (Conditional):**
```bicep
// Create secret only if connections exist
// Note: Connection data is provided by Radius at deployment time through context
var hasConnections = length(connections) > 0

resource connectionSecret 'core/Secret@v1' = if (hasConnections) {
  metadata: {
    name: '${resourceName}-connection-secret'
    namespace: namespace
    labels: commonLabels
  }
  type: 'Opaque'
  stringData: {
    // Connection environment variables injected by Radius
    // Actual implementation will iterate over connection values from context
    // Format expected: CONNECTION_<RESOURCE>_<PROPERTY>=<value>
    'connection-data': 'placeholder-for-radius-injected-connections'
  }
}

// Note: In production, connection values would come from:
// context.resource.properties.connections with resolved values
// Example: CONNECTION_REDIS_HOST, CONNECTION_REDIS_PORT, etc.
```

**Deployment Resource:**
```bicep
resource deployment 'apps/Deployment@v1' = {
  metadata: {
    name: resourceName
    namespace: namespace
    labels: union(commonLabels, customLabels, daprLabels)
    annotations: union(customAnnotations, daprAnnotations)
  }
  spec: {
    replicas: replicas
    selector: {
      matchLabels: selectorLabels
    }
    template: {
      metadata: {
        labels: union(commonLabels, customLabels, daprLabels)
        annotations: union(customAnnotations, daprAnnotations)
      }
      spec: {
        serviceAccountName: serviceAccount.metadata.name
        containers: [for containerName in items(containers): {
          name: containerName.key
          image: containerName.value.image
          ports: [for portName in items(containerName.value.?ports ?? {}): {
            name: portName.key
            containerPort: portName.value.containerPort
            protocol: portName.value.?protocol ?? 'TCP'
          }]
          env: concat(
            // Direct environment variables
            [for envName in items(containerName.value.?env ?? {}): {
              name: envName.key
              value: envName.value.?value
            } if envName.value.?value != null],
            // Secret-referenced environment variables
            [for envName in items(containerName.value.?env ?? {}): {
              name: envName.key
              valueFrom: {
                secretKeyRef: {
                  name: envName.value.valueFrom.secretKeyRef.secretId
                  key: envName.value.valueFrom.secretKeyRef.key
                }
              }
            } if envName.value.?valueFrom != null],
            // Connection environment variables
            hasConnections ? [{
              name: 'CONNECTION_INFO'
              valueFrom: {
                secretKeyRef: {
                  name: '${resourceName}-connection-secret'
                  key: 'connection-data'
                }
              }
            }] : []
          )
          resources: {
            requests: {
              cpu: containerName.value.?resources.?requests.?cpu ?? '100m'
              memory: containerName.value.?resources.?requests.?memoryInMib != null 
                ? '${containerName.value.resources.requests.memoryInMib}Mi' 
                : '128Mi'
            }
            limits: {
              cpu: containerName.value.?resources.?limits.?cpu ?? '500m'
              memory: containerName.value.?resources.?limits.?memoryInMib != null 
                ? '${containerName.value.resources.limits.memoryInMib}Mi' 
                : '512Mi'
            }
          }
          readinessProbe: containerName.value.?readinessProbe
          livenessProbe: containerName.value.?livenessProbe
          volumeMounts: [for mount in (containerName.value.?volumeMounts ?? []): {
            name: mount.volumeName
            mountPath: mount.mountPath
          }]
        }]
        volumes: [for v in items(volumes): {
          name: v.key
          emptyDir: v.value.?emptyDir ?? {}
        } if contains(v.value, 'emptyDir')]
        // Note: persistentVolume and secretId types will be added in Phase 2
      }
    }
  }
}
```

**Service Resource (Conditional):**
```bicep
// Determine if any container has ports
var hasPorts = length(flatten([for c in items(containers): items(c.value.?ports ?? {})])) > 0

resource service 'core/Service@v1' = if (hasPorts) {
  metadata: {
    name: resourceName
    namespace: namespace
    labels: commonLabels
  }
  spec: {
    type: 'ClusterIP'
    selector: selectorLabels
    ports: flatten([for c in items(containers): [for p in items(c.value.?ports ?? {}): {
      name: p.key
      port: p.value.containerPort
      targetPort: p.value.containerPort
      protocol: p.value.?protocol ?? 'TCP'
    }]])
  }
}
```

**Helper Variables:**

```bicep
// NOTE: Context schema reference: https://docs.radapp.io/reference/context-schema/
// Verify these context properties are available in your Radius version

// Common labels for all resources
var commonLabels = {
  'app.kubernetes.io/name': resourceName
  'app.kubernetes.io/part-of': applicationName
  'app.kubernetes.io/managed-by': 'radius'
  'radapp.io/application': applicationName
  'radapp.io/resource': resourceName
}

// Selector labels (subset of common labels for matching)
var selectorLabels = {
  'app.kubernetes.io/name': resourceName
  'radapp.io/application': applicationName
}

// Custom labels from platformOptions
var customLabels = platformOptions.?kubernetes.?metadata.?labels ?? {}
var customAnnotations = platformOptions.?kubernetes.?metadata.?annotations ?? {}

// Dapr extension support
var daprEnabled = contains(extensions, 'daprSidecar')
var daprLabels = daprEnabled ? {
  'dapr.io/enabled': 'true'
} : {}
var daprAnnotations = daprEnabled ? {
  'dapr.io/enabled': 'true'
  'dapr.io/app-id': extensions.daprSidecar.?appId ?? resourceName
  'dapr.io/app-port': string(extensions.daprSidecar.?appPort ?? 80)
  'dapr.io/config': extensions.daprSidecar.?config ?? ''
} : {}

// Environment variable arrays (Note: Bicep doesn't support user-defined functions)
// These would be computed per-container in the actual implementation
// Direct environment variables from container.env
var buildEnvVarsFromDirect = (container: object) => [for envName in items(container.?env ?? {}): {
  name: envName.key
  value: envName.value.?value
} if envName.value.?value != null]

// Secret-referenced environment variables
var buildEnvVarsFromSecrets = (container: object) => [for envName in items(container.?env ?? {}): {
  name: envName.key
  valueFrom: {
    secretKeyRef: {
      name: envName.value.valueFrom.secretKeyRef.secretId
      key: envName.value.valueFrom.secretKeyRef.key
    }
  }
} if envName.value.?valueFrom != null]

// Connection environment variables (injected by Radius automatically)
// Note: Radius handles connection env var injection at deployment time
// Recipe only needs to reference the secret if connections exist
var connectionEnvVars = length(connections) > 0 ? [{
  name: 'CONNECTION_INFO'
  valueFrom: {
    secretKeyRef: {
      name: '${resourceName}-connection-secret'
      key: 'connection-data'
    }
  }
}] : []

// Volume definitions - only emptyDir in Alpha
var emptyDirVolumes = [for v in items(volumes): {
  name: v.key
  emptyDir: v.value.?emptyDir ?? {}
} if contains(v.value, 'emptyDir')]

// Note: In actual implementation, use concat() to combine env var arrays per container
```

**Outputs:**

```bicep
// Simplified port selection logic
var firstContainer = items(containers)[0]
var firstContainerPorts = items(firstContainer.value.?ports ?? {})
var hasAnyPorts = length(firstContainerPorts) > 0
var firstPortNumber = hasAnyPorts ? firstContainerPorts[0].value.containerPort : 0

output result object = {
  resources: [
    '/planes/kubernetes/local/namespaces/${namespace}/providers/core/Service/${resourceName}'
    '/planes/kubernetes/local/namespaces/${namespace}/providers/apps/Deployment/${resourceName}'
  ]
  values: {
    host: hasPorts ? '${resourceName}.${namespace}.svc.cluster.local' : ''
    port: hasPorts ? string(firstPortNumber) : ''
  }
  secrets: {}
}
```

---

### 2.2 Recipe README: `kubernetes-containers.bicep/README.md`

#### A. Purpose and Scope

Platform engineer documentation explaining:
- What the recipe does
- How to customize it
- Input/output properties
- Prerequisites and limitations

#### B. Content Structure

```markdown
# Kubernetes Containers Recipe

## Overview

This Bicep recipe deploys containers to Kubernetes using the Bicep Kubernetes extension. It creates Kubernetes Deployment, Service, Secret, ServiceAccount, Role, and RoleBinding resources.

**Maturity Level:** Alpha  
**Platform:** Kubernetes  
**IaC Language:** Bicep

## Features

- ✅ Multi-container deployments
- ✅ Port exposure via ClusterIP Service
- ✅ Environment variable injection
- ✅ Connection-based environment variables
- ✅ Ephemeral volumes (emptyDir)
- ✅ Health probes (readiness/liveness)
- ✅ RBAC (ServiceAccount, Role, RoleBinding)
- ✅ Dapr sidecar support
- ✅ Manual scaling
- ✅ Custom Kubernetes metadata
- ⏳ Persistent volumes (Phase 2)
- ⏳ Secret volumes (Phase 2)
- ⏳ Auto-scaling (Phase 2)
- ⏳ Azure Workload Identity (Phase 2)

## Prerequisites

- Kubernetes cluster (v1.24+)
- Radius CLI with Kubernetes environment configured
- Bicep Kubernetes extension (preview)

## Recipe Input Properties

The recipe receives properties from the `Radius.Compute/containers` resource definition:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `containers` | object | Yes | Map of container specifications |
| `connections` | object | No | Resource connections for env var injection |
| `volumes` | object | No | Volume definitions (emptyDir only in Alpha) |
| `replicas` | integer | No | Number of replicas (default: 1) |
| `extensions.daprSidecar` | object | No | Dapr sidecar configuration |
| `platformOptions.kubernetes.metadata` | object | No | Custom labels and annotations |

### Container Specification

Each container in the `containers` map includes:

- `image` (required): Container image
- `ports`: Map of port definitions with `containerPort` and optional `protocol`
- `env`: Map of environment variables with `value` or `valueFrom`
- `resources.requests/limits`: CPU and memory constraints
- `readinessProbe/livenessProbe`: Health check configurations
- `volumeMounts`: Array of volume mount points

## Recipe Output Properties

The recipe returns connection information:

| Property | Type | Description |
|----------|------|-------------|
| `host` | string | Kubernetes Service DNS name |
| `port` | string | First exposed port (if any) |

## Usage Example

```bicep
extension radius

param environment string

resource app 'Applications.Core/applications@2023-10-01-preview' = {
  name: 'demo-app'
  properties: {
    environment: environment
  }
}

resource container 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'web'
  properties: {
    application: app.id
    environment: environment
    containers: {
      web: {
        image: 'nginx:latest'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
    replicas: 3
  }
}
```

## Customization

Platform engineers can customize this recipe by:

1. **Modifying resource defaults**: Change default CPU/memory limits in the recipe
   ```bicep
   // Example: Increase default limits
   cpu: containerName.value.?resources.?limits.?cpu ?? '1000m'  // Changed from 500m
   memory: '${containerName.value.?resources.?limits.?memoryInMib ?? 1024}Mi'  // Changed from 512
   ```

2. **Adding security policies**: Add pod security context
   ```bicep
   spec: {
     securityContext: {
       runAsNonRoot: true
       runAsUser: 1000
     }
   }
   ```

3. **Configuring network policies**: Add NetworkPolicy resources
   ```bicep
   resource networkPolicy 'networking.k8s.io/NetworkPolicy@v1' = {
     // Define ingress/egress rules
   }
   ```

4. **Adding init containers**: Support for init containers
   ```bicep
   initContainers: [
     // Add init container logic based on container.initContainer property
   ]
   ```

5. **Custom volume types**: Add support for ConfigMap volumes
   ```bicep
   // Add ConfigMap volume type alongside emptyDir
   ```

## Limitations (Alpha Stage)

- Only ephemeral volumes (emptyDir) supported
- No persistent volume mounting
- No secret volume mounting
- No auto-scaling configuration
- No Azure Workload Identity integration
- Limited base manifest merging

## Testing

Test this recipe using:

```bash
make build-bicep-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep
make test-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep
```

## Troubleshooting

### Recipe build fails
- Ensure Bicep Kubernetes extension is installed
- Check bicepconfig.json has correct extension reference

### Deployment fails
- Verify container image is accessible from cluster
- Check resource quotas in namespace
- Review pod logs: `kubectl logs -n <namespace> <pod-name>`

### Service not accessible
- Verify container ports are correctly defined
- Check Service selector matches Deployment labels
- Use `kubectl get svc,pods -n <namespace>` to verify resources

## References

- [Radius Recipes Documentation](https://docs.radapp.io/guides/recipes)
- [Bicep Kubernetes Extension](https://learn.microsoft.com/azure/azure-resource-manager/bicep/bicep-kubernetes-extension)
- [Kubernetes API Reference](https://kubernetes.io/docs/reference/kubernetes-api/)
```

---

### 2.3 Test Application: `test/app.bicep`

#### A. Purpose and Scope

A test application that validates the recipe's core Kubernetes deployment capabilities:
- Single and multi-container deployments
- Port exposure
- Environment variables
- Volume mounting (emptyDir)
- Connection to mock resource

**Critical Constraint:** MUST NOT include Azure/AWS resources - Kubernetes only!

#### B. Content Structure

```bicep
extension radius

@description('The Radius environment ID')
param environment string

// Create test application
resource app 'Applications.Core/applications@2023-10-01-preview' = {
  name: 'container-test-app'
  location: 'global'
  properties: {
    environment: environment
    extensions: [
      {
        kind: 'kubernetesNamespace'
        namespace: 'container-test'
      }
    ]
  }
}

// Test Case 1: Simple single container with port
resource simpleContainer 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'simple-container'
  properties: {
    application: app.id
    environment: environment
    containers: {
      nginx: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
        env: {
          NGINX_PORT: {
            value: '80'
          }
        }
      }
    }
  }
}

// Test Case 2: Multi-container deployment with shared volume
resource multiContainer 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'multi-container'
  properties: {
    application: app.id
    environment: environment
    containers: {
      frontend: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
        volumeMounts: [
          {
            volumeName: 'shared-data'
            mountPath: '/usr/share/nginx/html'
          }
        ]
      }
      sidecar: {
        image: 'busybox:latest'
        command: ['/bin/sh', '-c']
        args: ['while true; do echo "Hello from sidecar" > /data/index.html; sleep 30; done']
        volumeMounts: [
          {
            volumeName: 'shared-data'
            mountPath: '/data'
          }
        ]
      }
    }
    volumes: {
      'shared-data': {
        emptyDir: {}
      }
    }
  }
}

// Test Case 3: Container with health probes
resource containerWithProbes 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'container-probes'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
        readinessProbe: {
          httpGet: {
            path: '/'
            port: 80
          }
          initialDelaySeconds: 5
          periodSeconds: 10
        }
        livenessProbe: {
          httpGet: {
            path: '/'
            port: 80
          }
          initialDelaySeconds: 15
          periodSeconds: 20
        }
      }
    }
  }
}

// Test Case 4: Container with replica scaling
resource scaledContainer 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'scaled-container'
  properties: {
    application: app.id
    environment: environment
    containers: {
      web: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
    replicas: 3
  }
}

// Test Case 5: Container with Dapr sidecar (tests extension support)
resource daprContainer 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'dapr-container'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
    extensions: {
      daprSidecar: {
        appId: 'dapr-test-app'
        appPort: 80
      }
    }
  }
}

// Test Case 6: Container with custom Kubernetes metadata
resource containerWithMetadata 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'container-metadata'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
    platformOptions: {
      kubernetes: {
        metadata: {
          labels: {
            'custom-label': 'test-value'
            'team': 'platform'
          }
          annotations: {
            'description': 'Test container with custom metadata'
          }
        }
      }
    }
  }
}

// Test Case 7: Container with resource limits
resource containerWithResources 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'container-resources'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'nginx:alpine'
        resources: {
          requests: {
            cpu: '0.1'
            memoryInMib: 128
          }
          limits: {
            cpu: '0.5'
            memoryInMib: 512
          }
        }
      }
    }
  }
}

// Test Case 8: Container with connection to another container
resource containerWithConnection 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'container-connection'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'nginx:alpine'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
    connections: {
      backend: {
        source: simpleContainer.id
      }
    }
  }
}

// Output for validation
output simpleContainerName string = simpleContainer.name
output multiContainerName string = multiContainer.name
output containerWithConnectionName string = containerWithConnection.name
```

#### C. Test Validation Commands

After deployment, validate with:

```bash
# Check all pods are running
kubectl get pods -n container-test

# Verify simple container service
kubectl get svc simple-container -n container-test

# Check multi-container shared volume
kubectl exec -n container-test -c frontend $(kubectl get pod -n container-test -l app.kubernetes.io/name=multi-container -o jsonpath='{.items[0].metadata.name}') -- cat /usr/share/nginx/html/index.html

# Verify scaled container has 3 replicas
kubectl get deployment scaled-container -n container-test -o jsonpath='{.spec.replicas}'

# Check Dapr annotations
kubectl get pod -n container-test -l app.kubernetes.io/name=dapr-container -o jsonpath='{.items[0].metadata.annotations}'

# Verify custom labels
kubectl get deployment container-metadata -n container-test -o jsonpath='{.metadata.labels}'

# Check resource limits
kubectl get pod -n container-test -l app.kubernetes.io/name=container-resources -o jsonpath='{.items[0].spec.containers[0].resources}'
```

---

### 2.4 Test README: `test/README.md`

#### A. Content Structure

```markdown
# Container Recipe Test Application

## Overview

This test application validates the core Kubernetes deployment features of the `Radius.Compute/containers` recipe.

## Test Cases

The `app.bicep` file includes 8 test cases:

1. **Simple Container**: Single nginx container with port exposure
2. **Multi-Container**: Two containers sharing an emptyDir volume
3. **Health Probes**: Container with readiness and liveness probes
4. **Replica Scaling**: Container scaled to 3 replicas
5. **Dapr Extension**: Container with Dapr sidecar configuration
6. **Custom Metadata**: Container with custom Kubernetes labels/annotations
7. **Resource Limits**: Container with CPU/memory requests and limits
8. **Connection**: Container with connection to another container resource

## Running Tests

### Prerequisites

- Kubernetes cluster running (k3d, kind, or cloud)
- Radius installed with Kubernetes environment
- Container resource type registered

### Build and Test

```bash
# From repository root
cd Compute/containers

# Build the resource type
make build-resource-type TYPE_FOLDER=Compute/containers

# Build the recipe
make build-bicep-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep

# Run tests
make test-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep
```

### Manual Testing

```bash
# Deploy test application
rad deploy test/app.bicep -e <your-kubernetes-environment>

# Verify all pods are running
kubectl get pods -n container-test

# Check services created
kubectl get svc -n container-test

# Verify deployments
kubectl get deployments -n container-test

# Clean up
rad app delete container-test-app -e <your-kubernetes-environment>
```

## Validation Criteria

✅ All pods reach Running state  
✅ Services are created for containers with ports  
✅ Multi-container pods share volumes correctly  
✅ Health probes are configured correctly  
✅ Replica counts match specifications  
✅ Dapr annotations are applied  
✅ Custom labels and annotations are present  
✅ Resource limits are enforced  

## Troubleshooting

### Pods not starting
- Check image pull errors: `kubectl describe pod -n container-test <pod-name>`
- Verify resource quotas

### Services not accessible
- Verify port configurations
- Check service selectors match pod labels

### Volume mounting issues
- Check volume definitions in deployment spec
- Verify mount paths don't conflict

## Notes

- This test application does NOT include any cloud provider resources (Azure/AWS)
- Tests focus purely on Kubernetes deployment capabilities
- Connection testing with actual resources (Redis) should use the external demo application
```

---

## 3. Implementation Sequence

### Phase 1: Setup and Foundation (Day 1)

**Step 1: Create Directory Structure**
```bash
mkdir -p Compute/containers/recipes/kubernetes/bicep
mkdir -p Compute/containers/test
```

**Step 2: Create Main Recipe File**
- Create `kubernetes-containers.bicep`
- Start with basic structure: parameters, extension config, variables
- Implement ServiceAccount resource first (simplest)
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Recipe file compiles without errors

**Step 3: Implement RBAC Resources**
- Add Role resource
- Add RoleBinding resource
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** RBAC resources defined correctly

### Phase 2: Core Container Deployment (Days 2-3)

**Step 4: Implement Deployment Resource**
- Add basic Deployment with single container support
- Implement container iteration logic
- Add port mapping
- Add environment variables (direct values only)
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Deployment resource generates correctly

**Step 5: Implement Service Resource**
- Add conditional Service creation
- Implement port collection logic
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Service created when ports exist

**Step 6: Add Volume Support**
- Implement emptyDir volume logic
- Add volume mount mapping
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Volumes and mounts configured correctly

### Phase 3: Extensions and Advanced Features (Days 4-5)

**Step 7: Implement Dapr Support**
- Add Dapr annotation logic
- Add Dapr label logic
- Test with Dapr-enabled configuration
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Dapr annotations applied correctly

**Step 8: Implement Custom Metadata**
- Add platformOptions.kubernetes.metadata support
- Merge custom labels with common labels
- Merge custom annotations
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Custom metadata applied to resources

**Step 9: Add Connection Support**
- Implement Secret resource creation
- Add connection environment variable injection
- Add secretKeyRef support for env vars
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Connections create secrets and inject env vars

**Step 10: Add Outputs**
- Implement result output with host/port
- Add resource references
- Validate: `bicep build kubernetes-containers.bicep`

**Checkpoint:** Recipe returns correct output structure

### Phase 4: Documentation (Day 6)

**Step 11: Create Recipe README**
- Write `recipes/kubernetes/bicep/README.md`
- Include all sections from template above
- Add usage examples

**Checkpoint:** README is complete and accurate

### Phase 5: Testing (Days 7-8)

**Step 12: Create Test Application**
- Create `test/app.bicep` with all 8 test cases (including connection test)
- Validate: `bicep build test/app.bicep`

**Checkpoint:** Test app compiles successfully

**Step 13: Create Test README**
- Write `test/README.md`
- Document test cases and validation steps

**Checkpoint:** Test documentation complete

**Step 14: Build and Register Recipe**
```bash
# Build resource type
make build-resource-type TYPE_FOLDER=Compute/containers

# Build recipe
make build-bicep-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep

# Register recipe in environment
rad recipe register default \
  --environment <kubernetes-env> \
  --resource-type Radius.Compute/containers \
  --template-kind bicep \
  --template-path localhost:5000/recipes/containers-kubernetes:latest
```

**Checkpoint:** Recipe registered successfully

**Step 15: Run Test Application**
```bash
rad deploy test/app.bicep -e <kubernetes-env>
```

**Checkpoint:** All test cases deploy successfully

**Step 16: Validate Test Results**
- Run all kubectl validation commands from test README
- Verify pods, services, deployments
- Check annotations, labels, resource limits

**Checkpoint:** All validation checks pass

### Phase 6: Demo Validation (Day 9)

**Step 17: Deploy External Demo**
- Use demo from gist (Redis + container)
- Verify connection works
- Test port forwarding and access

**Checkpoint:** Demo application works end-to-end

**Step 18: Final Documentation Review**
- Review all README files
- Ensure examples are accurate
- Update any discrepancies

**Checkpoint:** Documentation is accurate and complete

---

## 4. Testing Strategy

### 4.1 Local Development Testing

**Tool:** Bicep CLI
```bash
# Validate syntax
bicep build kubernetes-containers.bicep

# Check for warnings
bicep lint kubernetes-containers.bicep
```

**Expected Result:** No errors or warnings

### 4.2 Recipe Build Testing

**Tool:** Make commands
```bash
# Build resource type
make build-resource-type TYPE_FOLDER=Compute/containers

# Build recipe
make build-bicep-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep
```

**Expected Result:** 
- `.tgz` file created
- Recipe pushed to local OCI registry
- `bicepconfig.json` updated

### 4.3 Unit Testing (Test Application)

**Tool:** rad deploy + kubectl
```bash
# Deploy test app
rad deploy test/app.bicep -e kubernetes-env

# Validate resources
kubectl get all -n container-test
```

**Validation Checklist:**
- [ ] All 8 test case pods are Running
- [ ] Services created for containers with ports
- [ ] Deployments have correct replica counts
- [ ] Dapr annotations present on dapr-container pod
- [ ] Custom labels visible on container-metadata deployment
- [ ] Resource limits enforced on container-resources pod
- [ ] Multi-container pod has 2 containers
- [ ] Shared volume accessible in multi-container pod
- [ ] Connection test container can reference backend container

### 4.4 Integration Testing (Demo Application)

**Tool:** External demo from gist
```bash
# Deploy demo with Redis
rad run app.bicep -e kubernetes-env

# Port forward to test
kubectl port-forward svc/demo 3000:3000 -n <namespace>

# Access in browser
curl http://localhost:3000
```

**Validation Checklist:**
- [ ] Demo container deployed successfully
- [ ] Redis connection established
- [ ] Environment variables injected correctly
- [ ] Service accessible via port-forward
- [ ] Application responds to HTTP requests

### 4.5 Kubernetes Resource Validation

**Commands:**

```bash
# Check Deployment
kubectl get deployment <container-name> -n <namespace> -o yaml

# Verify:
# - spec.replicas matches recipe input
# - containers array has correct images
# - environment variables present
# - volume mounts configured
# - labels and annotations applied

# Check Service
kubectl get service <container-name> -n <namespace> -o yaml

# Verify:
# - type is ClusterIP
# - ports match container ports
# - selector matches deployment labels

# Check Secret (if connections exist)
kubectl get secret <container-name>-secrets -n <namespace> -o yaml

# Verify:
# - stringData contains connection environment variables

# Check RBAC
kubectl get serviceaccount,role,rolebinding <container-name> -n <namespace>

# Verify:
# - ServiceAccount exists
# - Role has correct permissions
# - RoleBinding connects SA to Role
```

### 4.6 Negative Testing

**Test Cases:**
1. Missing required parameters (should fail validation)
2. Invalid image name (should fail pod creation)
3. Port conflicts (should fail service creation)
4. Invalid volume references (should fail mount)
5. Exceeding resource quotas (should fail scheduling)

**Expected Behavior:** Clear error messages, no partial deployments

### 4.7 Performance Testing

**Metrics to Measure:**
- Recipe execution time
- Pod startup time
- Resource consumption (CPU/memory)

**Acceptance Criteria:**
- Recipe execution < 30 seconds
- Pod startup < 2 minutes (depends on image size)
- No memory leaks or resource exhaustion

---

## 5. Documentation Requirements

### 5.1 Developer Documentation (containers.yaml)

**Location:** Already exists in `Compute/containers/containers.yaml`

**Enhancement Needed:** The description field already contains extensive documentation. Verify it includes:
- Basic usage example with the recipe
- Connection example
- Volume mounting example
- Extension examples

**No changes required** - the existing documentation is comprehensive.

### 5.2 Platform Engineer Documentation

**Location:** `Compute/containers/recipes/kubernetes/bicep/README.md`

**Content:** See Section 2.2 above for complete content.

**Key Sections:**
- Overview and features
- Prerequisites
- Input/output properties
- Usage examples
- Customization guidance
- Limitations
- Troubleshooting

### 5.3 Test Documentation

**Location:** `Compute/containers/test/README.md`

**Content:** See Section 2.4 above for complete content.

**Key Sections:**
- Test case descriptions
- Running instructions
- Validation criteria
- Troubleshooting

### 5.4 Usage Examples

**Example 1: Simple Web Container**
```bicep
resource web 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'web'
  properties: {
    application: app.id
    environment: environment
    containers: {
      nginx: {
        image: 'nginx:latest'
        ports: {
          http: {
            containerPort: 80
          }
        }
      }
    }
  }
}
```

**Example 2: Container with Redis Connection (Demo Scenario)**
```bicep
resource demo 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'demo'
  properties: {
    application: app.id
    environment: environment
    containers: {
      demo: {
        image: 'ghcr.io/radius-project/samples/demo:latest'
        ports: {
          web: {
            containerPort: 3000
          }
        }
      }
    }
    connections: {
      redis: {
        source: db.id
      }
    }
  }
}

resource db 'Applications.Datastores/redisCaches@2023-10-01-preview' = {
  name: 'db'
  properties: {
    application: app.id
    environment: environment
  }
}
```

**Example 3: Multi-Container with Shared Volume**
```bicep
resource multicontainer 'Radius.Compute/containers@2025-08-01-preview' = {
  name: 'multicontainer'
  properties: {
    application: app.id
    environment: environment
    containers: {
      app: {
        image: 'myapp:latest'
        volumeMounts: [
          {
            volumeName: 'data'
            mountPath: '/app/data'
          }
        ]
      }
      sidecar: {
        image: 'logger:latest'
        volumeMounts: [
          {
            volumeName: 'data'
            mountPath: '/logs'
          }
        ]
      }
    }
    volumes: {
      data: {
        emptyDir: {}
      }
    }
  }
}
```

---

## 6. Known Limitations and Future Work

### 6.1 Alpha Stage Limitations

**Not Implemented in Phase 1:**
1. **Persistent Volume Support**
   - Cannot mount PVCs from `Radius.Compute/persistentVolumes`
   - Only emptyDir volumes supported
   - **Workaround:** Use emptyDir for temporary storage
   - **Phase 2 Task:** Add PVC mounting logic

2. **Secret Volume Support**
   - Cannot mount secrets from `Radius.Security/secrets` as volumes
   - Secrets only available as environment variables
   - **Workaround:** Use environment variables for secrets
   - **Phase 2 Task:** Add secret volume mounting

3. **Auto-Scaling Configuration**
   - No HorizontalPodAutoscaler support
   - Manual scaling only via `replicas` property
   - **Workaround:** Set replica count manually
   - **Phase 2 Task:** Add HPA resource generation

4. **Azure Workload Identity**
   - No federated identity credential creation
   - No Azure-specific annotations
   - **Workaround:** Not available in Kubernetes-only recipe
   - **Future:** Consider in Azure-specific variant

5. **Base Manifest Merging**
   - Cannot merge user-provided YAML manifests
   - No pod spec patching support
   - **Workaround:** Use platformOptions for customization
   - **Future:** Investigate Bicep merge capabilities

6. **Init Container Support**
   - No support for init containers
   - **Workaround:** Use multi-container with manual ordering
   - **Phase 2 Task:** Add initContainers field support

7. **ConfigMap Volumes**
   - No ConfigMap volume mounting
   - **Workaround:** Use environment variables
   - **Phase 2 Task:** Add ConfigMap volume support

### 6.2 Technical Debt

1. **Environment Variable Complexity**
   - Connection env var injection is simplified in Alpha
   - Actual connection data comes from Radius at deployment time
   - May not handle all connection property types
   - **Refinement Needed:** Full connection value resolution and type conversion logic

2. **Bicep Function Limitations**
   - Bicep doesn't support user-defined functions
   - All array operations must be inline or in variables
   - Results in more verbose code
   - **Impact:** Less code reusability, more complex expressions

3. **Error Handling**
   - Limited validation of input parameters
   - Error messages may not be clear
   - No pre-deployment validation for port name length (15 char limit)
   - **Enhancement:** Add parameter validation and better error messages

4. **Output Structure**
   - Single host/port output only returns first port
   - Multi-port containers need better output structure
   - **Enhancement:** Return array of all endpoints with port names

5. **Label Management**
   - Label merging could conflict if same keys exist
   - No validation of label format (RFC 1123)
   - No validation of annotation size limits
   - **Enhancement:** Add label/annotation validation and conflict resolution

6. **Init Container Support**
   - Schema has `initContainer` property but not implemented in Alpha
   - **Enhancement:** Add proper init container ordering and execution

### 6.3 Path to Beta Maturity

**Requirements for Beta:**
1. ✅ Kubernetes Bicep recipe (Alpha complete)
2. ⏳ Terraform Kubernetes recipe
3. ⏳ Azure ACI Bicep recipe
4. ⏳ Azure ACI Terraform recipe
5. ⏳ AWS ECS Bicep recipe (if feasible)
6. ⏳ AWS ECS Terraform recipe
7. ✅ Automated testing (covered by test/app.bicep)
8. ⏳ Comprehensive documentation for all recipes
9. ⏳ Designated owner for each recipe variant

**Estimated Timeline:** 3-4 months after Alpha completion

### 6.4 Path to Stable Maturity

**Requirements for Stable:**
1. ✅ All Beta requirements
2. ⏳ 100% test coverage for all recipes
3. ⏳ Integration with Radius CI/CD pipeline
4. ⏳ Radius maintainers assume ownership of Kubernetes recipes
5. ⏳ Cloud recipe owners commit to SLA
6. ⏳ Production usage validation
7. ⏳ Performance benchmarking
8. ⏳ Security audit

**Estimated Timeline:** 6-12 months after Beta completion

### 6.5 Future Enhancements (Post-Stable)

1. **Advanced Networking**
   - Ingress resource creation
   - Network policy generation
   - Service mesh integration (Istio, Linkerd)

2. **Storage Options**
   - StatefulSet support
   - Dynamic volume provisioning
   - Snapshot support

3. **Security Features**
   - Pod security policies
   - Security context configuration
   - Image scanning integration

4. **Observability**
   - Prometheus metrics annotations
   - Logging sidecar injection
   - Tracing configuration

5. **Advanced Scheduling**
   - Node affinity rules
   - Pod anti-affinity
   - Topology spread constraints

6. **GitOps Integration**
   - Flux/ArgoCD compatibility
   - Manifest export for GitOps workflows

---

## 7. Risk Assessment and Mitigation

### 7.1 Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Bicep Kubernetes extension limitations | High | High | Thorough testing; document workarounds; fallback to manual resource creation |
| Complex environment variable logic | Medium | Medium | Simplify for Alpha; iterate based on feedback |
| Multi-container iteration complexity | Medium | High | Extensive testing with test app; validate with multiple scenarios |
| Connection injection incompleteness | Medium | Medium | Start with basic types; expand based on testing |
| Volume mounting edge cases | Low | Medium | Document limitations; test common scenarios |

### 7.2 Process Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Timeline slippage | Medium | Low | Phased approach allows for flexibility |
| Insufficient testing | Low | High | Comprehensive test app with 7 test cases |
| Documentation gaps | Medium | Medium | Template-based documentation; peer review |
| Demo environment issues | Medium | High | Local k3d cluster for consistent testing |

### 7.3 Dependency Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Bicep extension preview instability | Medium | High | Monitor extension updates; report issues upstream |
| Radius API changes | Low | High | Version pin; coordinate with Radius team |
| Kubernetes API changes | Low | Medium | Use stable API versions (v1) |

---

## 8. Success Metrics

### 8.1 Functional Metrics

- [ ] Recipe builds successfully with `make build-bicep-recipe`
- [ ] All 8 test cases in test/app.bicep deploy without errors (including connection test)
- [ ] Demo application from gist deploys successfully
- [ ] All Kubernetes resources created correctly (Deployment, Service, Secret, RBAC)
- [ ] Container connects to Redis and application responds
- [ ] Connection test case successfully references another container
- [ ] No regression in existing functionality

### 8.2 Quality Metrics

- [ ] Zero Bicep compilation errors
- [ ] Zero kubectl resource validation errors
- [ ] All validation commands in test README pass
- [ ] Documentation complete for all files
- [ ] Code review approval from maintainer
- [ ] Manual testing by independent tester passes

### 8.3 Performance Metrics

- [ ] Recipe execution time < 30 seconds
- [ ] Pod startup time < 2 minutes
- [ ] No memory leaks detected
- [ ] Resource usage within acceptable limits

### 8.4 User Experience Metrics

- [ ] Developer can deploy container in < 5 minutes using documentation
- [ ] Platform engineer can understand recipe customization from README
- [ ] Error messages are clear and actionable
- [ ] Examples work as documented

---

## 9. Approval and Sign-off

### 9.1 Review Checklist

Before submission:
- [ ] All files created as specified
- [ ] Recipe builds successfully
- [ ] Test application passes all validations
- [ ] Documentation complete and accurate
- [ ] Demo application works end-to-end
- [ ] Known limitations documented
- [ ] README files reviewed for clarity

### 9.2 Stakeholder Approval

- [ ] Technical lead review
- [ ] Documentation review
- [ ] Testing validation
- [ ] Radius maintainer approval

---

## 10. Appendices

### Appendix A: Bicep Kubernetes Extension Configuration

```json
// bicepconfig.json
{
  "experimentalFeaturesEnabled": {
    "extensibility": true
  },
  "extensions": {
    "radius": "br:ghcr.io/radius-project/bicep/extensions/radius:latest",
    "containers": "file:./containers-extension.tgz",
    "kubernetes": "br/public:bicep/extensions/kubernetes:preview"
  }
}
```

### Appendix B: Make Commands Reference

```bash
# Build resource type
make build-resource-type TYPE_FOLDER=Compute/containers

# Build Bicep recipe
make build-bicep-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep

# Test recipe
make test-recipe RECIPE_PATH=Compute/containers/recipes/kubernetes/bicep

# Build all
make build

# Test all
make test

# Clean up
make clean
```

### Appendix C: Kubernetes Resource Naming Conventions

All resources use consistent naming:
- **Base Name:** `context.resource.name` (e.g., "demo")
- **Namespace:** `context.runtime.kubernetes.namespace`
- **ServiceAccount:** `<base-name>`
- **Role:** `<base-name>`
- **RoleBinding:** `<base-name>`
- **Secret:** `<base-name>-secrets`
- **Deployment:** `<base-name>`
- **Service:** `<base-name>`

### Appendix D: Label and Annotation Standards

**Common Labels:**
```yaml
app.kubernetes.io/name: <resource-name>
app.kubernetes.io/part-of: <application-name>
app.kubernetes.io/managed-by: radius
radapp.io/application: <application-name>
radapp.io/resource: <resource-name>
```

**Dapr Annotations:**
```yaml
dapr.io/enabled: "true"
dapr.io/app-id: <app-id>
dapr.io/app-port: "<port>"
dapr.io/config: "<config-name>"
```

### Appendix E: Connection Environment Variable Format

When connections are defined, environment variables follow this pattern:
```
CONNECTION_<RESOURCE_NAME>_<PROPERTY>=<value>
```

Example:
```
CONNECTION_REDIS_HOST=redis.default.svc.cluster.local
CONNECTION_REDIS_PORT=6379
CONNECTION_REDIS_USERNAME=default
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-10-08 | GitHub Copilot | Initial comprehensive implementation plan |

---

**End of Implementation Plan**
